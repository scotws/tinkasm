MANUAL for A Typist's Assembler for the 65816 in Python 
Scot W. Stevenson <scot.stevenson@gmail.com>
First version: 24. Sep 2015
This version: 01. Nov 2015


- Requires Python 3.4 or later. Will not run with Python 2.7. 
- Does not distinguish between upper and lower case (internally, all is converted to lower case)



PARAMETERS

-i --input      - Input assembler file (required) 
-o --output     - Output file for the binary code, default is tasm.bin 
-l --listing    - Output file for the listing, default is tasm.txt  
-v --verbose    - Print more info about each assembly step
-d --dump       - Dump state of inbetween steps, produces lots of output


DIRECTIVES

By tradition, assembler directives start with a dot.


        *
        .A16
        .A8
        .AXY16
        .AXY8
        .BYTE / .B
        .EMULATED
        .END 
        .LONG / .L
        .NATIVE
        .ORIGIN
        .STRING / .STR
        .STRING0 / .STR0
        .STRINGLF / .STRLF
        .WORD / .W
        .XY16
        .XY8
        = 

INTERNAL STRUCTURE

The Typist's Assembler was built with a few assumptions in mind. First, the code to be assembled will be very small relative to current normal hardware specifications: The total memory space of the 65816 is 16 MB, while my machine 
has 16 GB of RAM. Because of this, saving space was a low priority. This is also true for speed, because programs are going to be relatively short (if we had wanted speed, we'd be using something like C or Go). The top priority was a clear design that will break up the process in as many small steps as possible to make the program easy to understand, easy to maintain and easy to change. 

For that reason, it was written in a "multipass" structure: Lots of little steps, usually as loops, that do exactly one thing and then pass a list on to the next step. 


(Tuples with original line number)




NOTES ON CODING STYLE 

Priority for the coding style was to make the program easy to understand -- and thereby also easy to modify and adapt -- for people who might not be familiar with the workings of an assembler. This is why Python was chosen as a language. Speed and compactness of code are secondary; in both these cases, the single-pass assember in Forth (https://github.com/scotws/tasm65816) is probably the better choice. 

In practical terms, what this means is that IF constructs were used even in cases when the result could have been achieved through calculation, because it allows a quicker understanding of the logic involved. 




